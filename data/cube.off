OFF
#
#  cube.off
#  A cube.
#  There is extra RGBA color information specified for the faces.
#
8 6 12
  1.632993   0.000000   1.154701 0 20 0
  0.000000   1.632993   1.154701 20 0 0
 -1.632993   0.000000   1.154701 40 40 40
  0.000000  -1.632993   1.154701 40 40 40
  1.632993   0.000000  -1.154701 0 20 0
  0.000000   1.632993  -1.154701 10 10 20
 -1.632993   0.000000  -1.154701 0 20 0
  0.000000  -1.632993  -1.154701 20 0 0
  4  0 1 2 3  1.000 0.000 0.000 0.75
  4  7 4 0 3  0.300 0.400 0.000 0.75
  4  4 5 1 0  0.200 0.500 0.100 0.75
  4  5 6 2 1  0.100 0.600 0.200 0.75
  4  3 2 6 7  0.000 0.700 0.300 0.75
  4  6 5 4 7  0.000 1.000 0.000 0.75

  //
  // Created by matteo on 01/09/18.
  //

  #include <unordered_map>
  #include <stack>
  #include <vector>
  #include <queue>
  #include <stopwatch.h>
  #include "MultiTreeManager.h"
  #include <omp.h>
  #include <MTSerialCreator.h>

  #include <GL/glew.h>
  #include <GLFW/glfw3.h>

  #include <cstdio>
  #include <zconf.h>
  #include <iostream>
  #include <CGAL/bounding_box.h>
  #include <MTVisualizer.h>

  struct MyPosData {
      GLdouble x = 0;
      GLdouble y = 0;
      GLdouble scale = 1;
      GLdouble translationX = 0;
      GLdouble translationY = 0;
      bool to_display = false;
  };

  void controls(GLFWwindow* window, int key, int scancode, int action, int mods)
  {
      if(action == GLFW_PRESS) {
          MyPosData *dataPtr = (MyPosData*)glfwGetWindowUserPointer(window);
          switch (key) {
              case GLFW_KEY_ESCAPE:
                  glfwSetWindowShouldClose(window, GL_TRUE);
                  break;
              case GLFW_KEY_SPACE:
                  dataPtr->to_display = false;
                  break;
              case GLFW_KEY_RIGHT_BRACKET:
                  dataPtr->scale += 0.5;
                  break;
              case GLFW_KEY_P:
                  dataPtr->scale -= 0.5;
                  break;
              case GLFW_KEY_A:
                  dataPtr->translationX -= 0.05;
                  break;
              case GLFW_KEY_D:
                  dataPtr->translationX += 0.05;
                  break;
              case GLFW_KEY_W:
                  dataPtr->translationY += 0.05;
                  break;
              case GLFW_KEY_S:
                  dataPtr->translationY -= 0.05;
                  break;
          }
      }
      if(action == GLFW_REPEAT) {
          MyPosData *dataPtr = (MyPosData*)glfwGetWindowUserPointer(window);
          switch (key) {
              case GLFW_KEY_RIGHT:
                  dataPtr->x -= 1;
                  break;
              case GLFW_KEY_LEFT:
                  dataPtr->x += 1;
                  break;
              case GLFW_KEY_DOWN:
                  dataPtr->y -= 1;
                  break;
              case GLFW_KEY_UP:
                  dataPtr->y += 1;
                  break;
          }
      }
  }

  GLFWwindow* initWindow(const int resX, const int resY)
  {
      if(!glfwInit())
      {
          fprintf(stderr, "Failed to initialize GLFW\n");
          return NULL;
      }
      glfwWindowHint(GLFW_SAMPLES, 4); // 4x antialiasing

      // Open a window and create its OpenGL context
      GLFWwindow* window = glfwCreateWindow(resX, resY, "TEST", NULL, NULL);

      if(window == NULL)
      {
          fprintf(stderr, "Failed to open GLFW window.\n");
          glfwTerminate();
          return NULL;
      }

      glfwMakeContextCurrent(window);
      glfwSetKeyCallback(window, controls);

      // Get info of GPU and supported OpenGL version
      printf("Renderer: %s\n", glGetString(GL_RENDERER));
      printf("OpenGL version supported %s\n", glGetString(GL_VERSION));

      glEnable(GL_DEPTH_TEST); // Depth Testing
      glDepthFunc(GL_LEQUAL);
      glDisable(GL_CULL_FACE);
      glCullFace(GL_BACK);
      return window;
  }

  void drawCube(GLFWwindow* window,std::vector<GLfloat> coords,std::vector<GLfloat> colors)
  {
      std::vector<GLfloat> vertini = {-1,-1,-1,-1,-1,1,-1,1,1};
      GLfloat vertices[] =
              {
                      -1, -1, -1,   -1, -1,  1,   -1,  1,  1,   -1,  1, -1,
                      1, -1, -1,    1, -1,  1,    1,  1,  1,    1,  1, -1,
                      -1, -1, -1,   -1, -1,  1,    1, -1,  1,    1, -1, -1,
                      -1,  1, -1,   -1,  1,  1,    1,  1,  1,    1,  1, -1,
                      -1, -1, -1,   -1,  1, -1,    1,  1, -1,    1, -1, -1,
                      -1, -1,  1,   -1,  1,  1,    1,  1,  1,    1, -1,  1
              };

      //GLfloat colors[] =
              //{
               //       0, 0, 0,   0, 0, 1,   0, 1, 1
              //};

      MyPosData *dataPtr = (MyPosData*)glfwGetWindowUserPointer(window);
      static float alpha = 0;
      //attempt to rotate cube
      glRotatef(dataPtr->x, 0, 1, 0);
      glRotatef(dataPtr->y,1,0,0);

      /* We have a color array and a vertex array */
      glEnableClientState(GL_VERTEX_ARRAY);
      glEnableClientState(GL_COLOR_ARRAY);
      glVertexPointer(3, GL_FLOAT, 0, coords.data());
      glColorPointer(3, GL_FLOAT, 0, colors.data());

      /* Send data : 24 vertices */
      int size = coords.size();
      glScalef(dataPtr->scale,dataPtr->scale,dataPtr->scale);
      glTranslatef(dataPtr->translationX, dataPtr->translationY,0);
      glDrawArrays(GL_TRIANGLES, 0, coords.size()/3);

      /* Cleanup states */
      glDisableClientState(GL_COLOR_ARRAY);
      glDisableClientState(GL_VERTEX_ARRAY);
      alpha += 1;
  }

  MultiTreeNode* MultiTreeManager::meshToTree(Mesh mesh, MultiTreeManager::CreationMode mode, int max_depth) {
      Dual dual(mesh);
      FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
      MTSerialCreator mt_serial_creator;

      if(mode == CreationMode::DF)
          return meshToTreeDF(mesh,max_depth,max_depth);
      else if(mode == CreationMode::LTR)
          return mt_serial_creator.createSerialTree(finiteDual,mode,max_depth);
      else return meshToTreeNormal(mesh,CreationMode::LTR,max_depth);
      //return meshToTreeNormal(mesh,mode,max_depth);
  }

  /*MultiTreeNode* MultiTreeManager::meshToTreeNormal(Mesh mesh, MultiTreeManager::CreationMode mode, int max_depth){
      GLFWwindow* window = initWindow(1024, 620);
      MyPosData my_pos_data;
      glfwSetWindowUserPointer(window,&my_pos_data);

      Stopwatch stopwatch;
      stopwatch.start();
      Dual dual(mesh);
      double elapsed = stopwatch.stop();
      std::cout << "Conversion took " << elapsed << " seconds" << std::endl;
      FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
      boost::graph_traits<FiniteDual>::vertex_iterator vb,ve;
      boost::tie(vb,ve) = boost::vertices(finiteDual);

      std::map<int,bool> inserted_map;
      stopwatch.start();
      for(int i = 0; i < boost::num_vertices(finiteDual); i++) {
          inserted_map.insert({i,false});
      }
      elapsed = stopwatch.stop();
      std::cout << "Map creation took " << elapsed << " seconds" << std::endl;

      std::unordered_map<boost::graph_traits<FiniteDual>::vertex_descriptor, MultiTreeNode*> node_map;
      std::vector<MultiTreeNode*> tree_queue;
      auto * root = new MultiTreeNode;
      root->level = 0;
      root->value = 1;
      root->id = *vb;

      node_map.insert({*vb,root});
      tree_queue.push_back(root);

      inserted_map.at(*vb) = true;
      MultiTreeNode* cursor = tree_queue.front();

      bool balanced_ltr = false;
      bool to_flip = false;
      std::vector<GLfloat> coords,colors;
      int count = 0;

      while (!tree_queue.empty()) {
          if (my_pos_data.to_display) {
              GLint windowWidth, windowHeight;
              glfwGetWindowSize(window, &windowWidth, &windowHeight);
              glViewport(0, 0, windowWidth, windowHeight);

              // Draw stuff
              glClearColor(0.9, 0.9, 0.8, 1.0);
              glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

              glMatrixMode(GL_PROJECTION_MATRIX);
              glLoadIdentity();

              gluPerspective(60, (double) windowWidth / (double) windowHeight, 0.1, 100);

              glMatrixMode(GL_MODELVIEW_MATRIX);
              glTranslatef(0, 0, -5);

              drawCube(window,coords,colors);

              // Update Screen
              glfwSwapBuffers(window);

              // Check for any input, or window movement
              glfwPollEvents();

          } else {
              boost::graph_traits<FiniteDual>::adjacency_iterator ai, ai_end;
              MultiTreeNode *front_element = tree_queue.front();

              std::vector<MultiTreeNode *> tmp_queue;

              int state = 0;

              for (boost::tie(ai, ai_end) = boost::adjacent_vertices(front_element->id, finiteDual); ai != ai_end; ++ai) {
                  if (!inserted_map.at(*ai)) {
                      inserted_map.at(*ai) = true;

                      CGAL::Vertex_around_face_iterator<Mesh> vafb,vafe;
                      int lop = 0;
                      for(boost::tie(vafb,vafe) = CGAL::vertices_around_face(mesh.halfedge(*ai),mesh);vafb != vafe;++vafb) {
                          Point p = (Point)mesh.point(*vafb);
                          coords.push_back(p.x());
                          coords.push_back(p.y());
                          coords.push_back(p.z());

                          if(lop == 0)
                              colors.push_back(1.0);
                          else
                              colors.push_back(0.0);

                          if(lop == 1)
                              colors.push_back(1.0);
                          else
                              colors.push_back(0.0);

                          if(lop == 2)
                              colors.push_back(1.0);
                          else
                              colors.push_back(0.0);

                          lop++;
                      }
                      if(count == 1500) {
                          my_pos_data.to_display = true;
                          count = 0;
                      } else
                          ++count;

                      auto *curr_node = new MultiTreeNode;
                      curr_node->id = *ai;
                      curr_node->parent = front_element;
                      curr_node->level = curr_node->parent->level + 1;

                      state++;

                      switch (state) {
                          case 1:
                              curr_node->parent->left = curr_node;
                              break;
                          case 2:
                              curr_node->parent->right = curr_node;
                              break;
                          default:
                              curr_node->parent->mid = curr_node; // Reached only for the root...
                              break;
                      }


                      node_map.insert({*ai, curr_node});
                      if (mode == CreationMode::RTL || (mode == CreationMode::BALANCED && balanced_ltr) ||
                          (mode == CreationMode::HYPER_FLIP && to_flip))
                          tmp_queue.push_back(curr_node);
                      else {
                          curr_node->prev = cursor;
                          if (cursor != nullptr)
                              curr_node->prev->next = curr_node;
                          cursor = curr_node;
                          tree_queue.push_back(curr_node);
                      }
                  } else if (front_element->parent != nullptr) {

                      if (front_element->parent->id != *ai) {
                          MultiTreeNode *old_node = node_map.at(*ai);


                          if (front_element->level - old_node->level < max_depth &&
                              front_element->level - old_node->level >= 0)
                              old_node->relatives.push_back(front_element);
                      }
                  }
              }

              if (mode == CreationMode::RTL || (mode == CreationMode::BALANCED && balanced_ltr) ||
                  (mode == CreationMode::HYPER_FLIP && to_flip)) {
                  std::reverse(tmp_queue.begin(), tmp_queue.end());
                  for (auto &node : tmp_queue) {
                      node->prev = cursor;
                      if (cursor != nullptr)
                          node->prev->next = node;
                      cursor = node;
                      tree_queue.push_back(node);
                  }
              }

              to_flip = !to_flip;
              tree_queue.erase(tree_queue.begin());
              if (mode == CreationMode::BALANCED) {
                  int curr_level = front_element->level;

                  if (tree_queue.front()->level != curr_level) {
                      std::reverse(tree_queue.begin(), tree_queue.end());
                      balanced_ltr = !balanced_ltr;
                  }
              }

              //front_element = front_element->next;
          }
      }

      return root;
  }*/

  MultiTreeNode* MultiTreeManager::meshToTreeNormal(Mesh mesh, MultiTreeManager::CreationMode mode, int max_depth){

      /*---- Initialize the dual graph and select a starting face ----*/
      Dual dual(mesh);
      FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
      boost::graph_traits<FiniteDual>::vertex_descriptor root_dsc = *mesh.faces_begin();

      /*---- Initialize the utility vectors ----*/
      std::vector<bool> inserted_map(boost::num_vertices(finiteDual),false);
      std::vector<MultiTreeNode*> node_real(boost::num_vertices(finiteDual), nullptr);
      std::vector<std::vector<boost::graph_traits<FiniteDual>::vertex_descriptor>> relatives_id(boost::num_vertices(finiteDual));

      /*---- Setup the tree root ----*/
      MultiTreeNode* root = new MultiTreeNode;
      root->id = root_dsc;
      root->level = 0;
      inserted_map[root_dsc] = true;
      node_real[0] = root;

      /*---- Create the first generation of the tree ----*/
      boost::graph_traits<FiniteDual>::adjacency_iterator aib_first,aie_first;
      int state_first = 0;
      for (boost::tie(aib_first,aie_first)=boost::adjacent_vertices(root->id,finiteDual); aib_first != aie_first; ++aib_first) {

          MultiTreeNode *curr_node = new MultiTreeNode;
          curr_node->id = *aib_first;
          curr_node->parent = root;
          curr_node->level = curr_node->parent->level + 1;

          state_first++;

          switch (state_first) {
              case 1:
                  curr_node->parent->left = curr_node;
                  break;
              case 2:
                  curr_node->parent->right = curr_node;
                  break;
              default:
                  curr_node->parent->mid = curr_node;
                  break;
              }

          inserted_map[*aib_first] = true;
          node_real[*aib_first] = curr_node;
      }

      /*---- Parallel phase setup ----*/
      MultiTreeNode* left_node = root->left;
      MultiTreeNode* right_node = root->right;
      MultiTreeNode* mid_node = root->mid;
      omp_lock_t insertion_lock;
      omp_init_lock(&insertion_lock);

      #pragma omp parallel num_threads(3) shared(inserted_map,node_real)
      {
          MultiTreeNode *front_element = nullptr;
          MultiTreeNode *cursor = nullptr;

          switch (omp_get_thread_num()) {
              case 0:
                  front_element = left_node;
                  break;
              case 1:
                  front_element = right_node;
                  break;
              case 2:
                  front_element = mid_node;
                  break;
              default:
                  std::cerr << "Process number different than expected" << std::endl;
                  exit(1);
          }
          cursor = front_element;

          while (front_element != nullptr) {
              boost::graph_traits<FiniteDual>::adjacency_iterator ai,ai_end;

              int state = 0;

              for (boost::tie(ai,ai_end)=boost::adjacent_vertices(front_element->id,finiteDual);ai != ai_end; ++ai) {
                  bool flag = false;
                  MultiTreeNode *curr_node = nullptr;

                  omp_set_lock(&insertion_lock);
                  if(!inserted_map[*ai]) {
                      inserted_map[*ai] = true;
                      omp_unset_lock(&insertion_lock);

                      MultiTreeNode *curr_node = new MultiTreeNode;
                      curr_node->id = *ai;
                      curr_node->parent = front_element;
                      curr_node->level = curr_node->parent->level + 1;

                      state++;

                      switch (state) {
                          case 1:
                              curr_node->parent->left = curr_node;
                              break;
                          case 2:
                              curr_node->parent->right = curr_node;
                              break;
                          default:
                              curr_node->parent->mid = curr_node; // Reached only for the root...
                              break;
                      }

                      node_real[*ai] = curr_node;

                      curr_node->prev = cursor;
                      cursor->next = curr_node;
                      cursor = curr_node;

                  } else {
                      omp_unset_lock(&insertion_lock);
                      if(front_element->parent->id != *ai) {
                          relatives_id[*ai].emplace_back(front_element->id);
                      }
                  }
              }

          front_element = front_element->next;
          }
      }

      #pragma omp parallel for num_threads(4)
          for (int i = 0; i < relatives_id.size(); ++i) {
              std::vector<boost::graph_traits<FiniteDual>::vertex_descriptor> elem = relatives_id[i];
              if (!elem.empty()) {
                  for (boost::graph_traits<FiniteDual>::vertex_descriptor dsc : elem) {
                      node_real[i]->relatives.emplace_back(node_real[dsc]);
                  }
              }
          }

      MultiTreeNode* curr_node = root;
      MultiTreeNode* cursor = root;

      if(curr_node->left != nullptr) {
          MultiTreeNode* left = curr_node->left;
          left->prev = cursor;
          cursor->next = left;
          cursor = left;
      }

      if(curr_node->right != nullptr) {
          MultiTreeNode* right = curr_node->right;
          right->prev = cursor;
          cursor->next = right;
          cursor = right;
      }

      if(curr_node->mid != nullptr) {
          MultiTreeNode* mid = curr_node->mid;
          mid->prev = cursor;
          cursor->next = mid;
          cursor = mid;
      }

      curr_node = curr_node->next;

      while(curr_node != nullptr) {

          if(curr_node->left != nullptr) {
              MultiTreeNode* left = curr_node->left;
              left->prev = cursor;
              cursor->next = left;
              cursor = left;
          }

          if(curr_node->right != nullptr) {
              MultiTreeNode* right = curr_node->right;
              right->prev = cursor;
              cursor->next = right;
              cursor = right;
          }

          curr_node = curr_node->next;
      }

      return root;
  }

  MultiTreeNode* MultiTreeManager::meshToTreeDF(Mesh mesh, int max_depth, int mode){

      // In case of wrong usage, assing default depth first expantion mode
      if(mode != 0 && mode != 1 && mode != 2)
          mode = 0;

      Dual dual(mesh);
      FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
      boost::graph_traits<FiniteDual>::vertex_iterator vb,ve;
      boost::tie(vb,ve) = boost::vertices(finiteDual);

      std::map<int,bool> inserted_map;
      for(int i = 0; i < boost::num_vertices(finiteDual); i++) {
          inserted_map.insert({i,false});
      }

      std::unordered_map<boost::graph_traits<FiniteDual>::vertex_descriptor, MultiTreeNode*> node_map;
      std::stack<MultiTreeNode*> tree_stack;
      auto * root = new MultiTreeNode;
      root->level = 0;
      root->value = 1;
      root->id = *vb;

      node_map.insert({*vb,root});
      tree_stack.push(root);

      inserted_map.at(*vb) = true;
      MultiTreeNode* cursor = root;

      bool flip = false;

      while (!tree_stack.empty()) {
          boost::graph_traits<FiniteDual>::adjacency_iterator ai,ai_end;
          MultiTreeNode* front_element = tree_stack.top();

          std::vector<MultiTreeNode*> tmp_queue;

          int state = 0;

          for (boost::tie(ai,ai_end)=boost::adjacent_vertices(front_element->id,finiteDual);ai != ai_end; ++ai) {
              if(!inserted_map.at(*ai)) {
                  inserted_map.at(*ai) = true;

                  auto *curr_node = new MultiTreeNode;
                  curr_node->id = *ai;
                  curr_node->parent = front_element;
                  curr_node->level = curr_node->parent->level + 1;

                  state++;

                  switch (state) {
                      case 1:
                          curr_node->parent->left = curr_node;
                          break;
                      case 2:
                          curr_node->parent->right = curr_node;
                          break;
                      default:
                          curr_node->parent->mid = curr_node; // Reached only for the root...
                          break;
                  }

                  node_map.insert({*ai,curr_node});
                  tmp_queue.push_back(curr_node);
              }
          }

          tree_stack.pop();

          if (mode == 0) {
              std::reverse(tmp_queue.begin(), tmp_queue.end());
          } else if (mode == 1) {
              if (!flip) {
                  std::reverse(tmp_queue.begin(), tmp_queue.end());
              }
              flip = !flip;
          }

          for (auto &node : tmp_queue) {
              node->prev = cursor;
              if(cursor != nullptr)
                  node->prev->next = node;
              cursor = node;
              tree_stack.push(node);
          }
      }

      return root;
  }

  void MultiTreeManager::addAreasToTree(MultiTreeNode* root, std::map<boost::graph_traits<Mesh>::face_descriptor,double> areas) {

      MultiTreeNode* curr_node = root;

      while(curr_node != nullptr) {
          double curr_area = areas[curr_node->id];
          curr_node->area = curr_area;
          curr_node = curr_node->next;
      }
  }

  void MultiTreeManager::regenerateTree(MultiTreeNode *root, std::vector<int> group_ids){
      std::queue<MultiTreeNode*> tree_queue;
      int curr_group = group_ids.at(root->id);
      tree_queue.push(root);
      MultiTreeNode* cursor = nullptr;
      root->prev = nullptr;
      root->parent = nullptr;

      while(!tree_queue.empty()) {
          MultiTreeNode* curr_node = tree_queue.front();
          curr_node->value = 1;
          curr_node->valid = true;
          curr_node->propagated = false;
          curr_node->prev = cursor;
          curr_node->next = nullptr;

          if(cursor != nullptr)
              curr_node->prev->next = curr_node;

          if(curr_node->left != nullptr) {
              if(group_ids.at(curr_node->left->id) == curr_group) {
                  tree_queue.push(curr_node->left);
              } else {
                  curr_node->left = nullptr;
              }
          }

          if(curr_node->right != nullptr) {
              if(group_ids.at(curr_node->right->id) == curr_group) {
                  tree_queue.push(curr_node->right);
              } else {
                  curr_node->right = nullptr;
              }
          }

          if(curr_node->mid != nullptr) {
              if(group_ids.at(curr_node->mid->id) == curr_group) {
                  tree_queue.push(curr_node->mid);
              } else {
                  curr_node->mid = nullptr;
              }
          }

          std::vector<MultiTreeNode*> tmp;
          for(auto &descendant : curr_node->relatives) {
              if(group_ids.at(descendant->id) != curr_group)
                  tmp.push_back(descendant);
          }
          curr_node->relatives.clear();
          curr_node->relatives.insert(curr_node->relatives.end(),tmp.begin(),tmp.end());

          cursor = curr_node;
          tree_queue.pop();
      }
  }

  void MultiTreeManager::linkTrees(std::vector<MultiTreeNode*>* tree_roots) {

      for(unsigned int i = 0; i < tree_roots->size()-1; ++i) {
          MultiTreeNode* curr_root = tree_roots->at(i);

          if(curr_root->left == nullptr) {
              curr_root->left = tree_roots->at(i+1);
              tree_roots->at(i+1)->parent = curr_root;
              continue;
          }

          if(curr_root->right == nullptr) {
              curr_root->right = tree_roots->at(i+1);
              tree_roots->at(i+1)->parent = curr_root;
              continue;
          }

          std::cerr << "Something wrong here, nodes have only two children at most!" << std::endl;
      }
  }

  void drawTree(GLFWwindow* window,std::vector<GLfloat> coords,std::vector<GLfloat> colors) {

      MyPosData *dataPtr = (MyPosData *) glfwGetWindowUserPointer(window);
      static float alpha = 0;
  //attempt to rotate cube
      glRotatef(dataPtr->x, 0, 1, 0);
      glRotatef(dataPtr->y, 1, 0, 0);

  /* We have a color array and a vertex array */
      glEnableClientState(GL_VERTEX_ARRAY);
      glEnableClientState(GL_COLOR_ARRAY);
      glVertexPointer(3, GL_FLOAT, 0, coords.data());
      glColorPointer(3, GL_FLOAT, 0, colors.data());

  /* Send data : 24 vertices */
      glScalef(dataPtr->scale, dataPtr->scale, dataPtr->scale);
      glTranslatef(dataPtr->translationX, dataPtr->translationY, 0);
      glDrawArrays(GL_LINES, 0, coords.size()/3);
      glDrawArrays(GL_LINES, 0, coords.size()/3);

      glPointSize(10.0);
      glBegin(GL_POINTS);
      glVertex3f(coords.at(0),coords.at(1),coords.at(2));
      glColor4f(1.0f,0.0f,0.0f,1.0f);
      glEnd();

  /* Cleanup states */
      glDisableClientState(GL_COLOR_ARRAY);
      glDisableClientState(GL_VERTEX_ARRAY);
      alpha += 1;
  }

  void drawTrees(GLFWwindow* window,std::vector<GLfloat> coords_1,std::vector<GLfloat> colors_1, std::vector<GLfloat> coords_2,std::vector<GLfloat> colors_2) {

      MyPosData *dataPtr = (MyPosData *) glfwGetWindowUserPointer(window);
      static float alpha = 0;
  //attempt to rotate cube
      glRotatef(dataPtr->x, 0, 1, 0);
      glRotatef(dataPtr->y, 1, 0, 0);

  /* We have a color array and a vertex array */
      glEnableClientState(GL_VERTEX_ARRAY);
      glEnableClientState(GL_COLOR_ARRAY);
      glVertexPointer(3, GL_FLOAT, 0, coords_1.data());
      glColorPointer(4, GL_FLOAT, 0, colors_1.data());

      glScalef(dataPtr->scale, dataPtr->scale, dataPtr->scale);
      glTranslatef(dataPtr->translationX, dataPtr->translationY, 0);
      glDrawArrays(GL_LINES, 0, coords_1.size()/3);

      glPointSize(10.0);
      glBegin(GL_POINTS);
      glVertex3f(coords_1.at(0),coords_1.at(1),coords_1.at(2));
      glColor4f(1.0f,0.0f,0.0f,1.0f);
      glEnd();

  /* Cleanup states */
      glDisableClientState(GL_COLOR_ARRAY);
      glDisableClientState(GL_VERTEX_ARRAY);
      alpha += 1;
  }

  void MultiTreeManager::visualize3DTree(MultiTreeNode *root, std::map<boost::graph_traits<Mesh>::face_descriptor,Point> centroids) {
      MTVisualizer visualizer;
      visualizer.visualize3DTree(root,centroids);
      exit(0);
      GLFWwindow* window = initWindow(1024, 620);
      MyPosData my_pos_data;
      glfwSetWindowUserPointer(window,&my_pos_data);
      root = root->next;

      std::vector<GLfloat> coords, colors;

      while(root != nullptr) {
          Point p = centroids.at(root->id);
          Point pp =  centroids.at(root->parent->id);
          coords.push_back(p.x());
          coords.push_back(p.y());
          coords.push_back(p.z());
          coords.push_back(pp.x());
          coords.push_back(pp.y());
          coords.push_back(pp.z());

          colors.push_back(0.0);
          colors.push_back(0.0);
          colors.push_back(0.0);
          colors.push_back(0.0);
          colors.push_back(0.0);
          colors.push_back(0.0);

          root = root->next;
      }

      my_pos_data.to_display = true;
      std::cout << coords.size() << std::endl;
      std::cout << colors.size() << std::endl;

      while (my_pos_data.to_display) {
          GLint windowWidth, windowHeight;
          glfwGetWindowSize(window, &windowWidth, &windowHeight);
          glViewport(0, 0, windowWidth, windowHeight);

          // Draw stuff
          glClearColor(0.9, 0.9, 0.9, 1.0);
          glEnable(GL_BLEND);
          glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

          glMatrixMode(GL_PROJECTION_MATRIX);
          glLoadIdentity();

          gluPerspective(60, (double) windowWidth / (double) windowHeight, 0.1, 100);

          glMatrixMode(GL_MODELVIEW_MATRIX);
          glTranslatef(0, 0, -5);

          drawTree(window,coords,colors);

          // Update Screen
          glfwSwapBuffers(window);

          // Check for any input, or window movement
          glfwPollEvents();
      }
  }

  void MultiTreeManager::compare3DTrees(MultiTreeNode *root_1,MultiTreeNode *root_2, std::map<boost::graph_traits<Mesh>::face_descriptor,Point> centroids) {
      GLFWwindow* window = initWindow(1024, 620);
      MyPosData my_pos_data;
      glfwSetWindowUserPointer(window,&my_pos_data);
      root_1 = root_1->next;
      root_2 = root_2->next;

      std::vector<GLfloat> coords_1, coords_2, colors_1, colors_2;

      while(root_1 != nullptr) {
          Point p = centroids.at(root_1->id);
          Point pp =  centroids.at(root_1->parent->id);
          coords_1.push_back(p.x());
          coords_1.push_back(p.y());
          coords_1.push_back(p.z());
          coords_1.push_back(pp.x());
          coords_1.push_back(pp.y());
          coords_1.push_back(pp.z());

          colors_1.push_back(1.0);
          colors_1.push_back(1.0);
          colors_1.push_back(0.0);
          colors_1.push_back(0.5);
          colors_1.push_back(1.0);
          colors_1.push_back(1.0);
          colors_1.push_back(0.0);
          colors_1.push_back(0.5);

          root_1 = root_1->next;
      }

      while(root_2 != nullptr) {
          Point p = centroids.at(root_2->id);
          Point pp =  centroids.at(root_2->parent->id);
          coords_1.push_back(p.x());
          coords_1.push_back(p.y());
          coords_1.push_back(p.z());
          coords_1.push_back(pp.x());
          coords_1.push_back(pp.y());
          coords_1.push_back(pp.z());

          colors_1.push_back(0.0);
          colors_1.push_back(0.0);
          colors_1.push_back(1.0);
          colors_1.push_back(0.5);
          colors_1.push_back(0.0);
          colors_1.push_back(0.0);
          colors_1.push_back(1.0);
          colors_1.push_back(0.5);

          root_2 = root_2->next;
      }

      my_pos_data.to_display = true;

      while (my_pos_data.to_display) {
          GLint windowWidth, windowHeight;
          glfwGetWindowSize(window, &windowWidth, &windowHeight);
          glViewport(0, 0, windowWidth, windowHeight);

          // Draw stuff
          glClearColor(1.0, 0.0, 0.0, 1.0);
          glEnable(GL_BLEND);
          glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

          glMatrixMode(GL_PROJECTION_MATRIX);
          glLoadIdentity();

          gluPerspective(60, (double) windowWidth / (double) windowHeight, 0.1, 100);

          glMatrixMode(GL_MODELVIEW_MATRIX);
          glTranslatef(0, 0, -5);

          drawTrees(window,coords_1,colors_1,coords_2,colors_2);

          // Update Screen
          glfwSwapBuffers(window);

          // Check for any input, or window movement
          glfwPollEvents();
      }
  }

MultiTreeNode* MultiTreeManager::meshToTreeDF(Mesh mesh, int max_depth, int mode){

    // In case of wrong usage, assing default depth first expantion mode
    if(mode != 0 && mode != 1 && mode != 2)
        mode = 0;

    Dual dual(mesh);
    FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
    boost::graph_traits<FiniteDual>::vertex_iterator vb,ve;
    boost::tie(vb,ve) = boost::vertices(finiteDual);

    std::map<int,bool> inserted_map;
    for(int i = 0; i < boost::num_vertices(finiteDual); i++) {
        inserted_map.insert({i,false});
    }

    std::unordered_map<boost::graph_traits<FiniteDual>::vertex_descriptor, MultiTreeNode*> node_map;
    std::stack<MultiTreeNode*> tree_stack;
    auto * root = new MultiTreeNode;
    root->level = 0;
    root->value = 1;
    root->id = *vb;

    node_map.insert({*vb,root});
    tree_stack.push(root);

    inserted_map.at(*vb) = true;
    MultiTreeNode* cursor = root;

    bool flip = false;

    while (!tree_stack.empty()) {
        boost::graph_traits<FiniteDual>::adjacency_iterator ai,ai_end;
        MultiTreeNode* front_element = tree_stack.top();

        std::vector<MultiTreeNode*> tmp_queue;

        int state = 0;

        for (boost::tie(ai,ai_end)=boost::adjacent_vertices(front_element->id,finiteDual);ai != ai_end; ++ai) {
            if(!inserted_map.at(*ai)) {
                inserted_map.at(*ai) = true;

                auto *curr_node = new MultiTreeNode;
                curr_node->id = *ai;
                curr_node->parent = front_element;
                curr_node->level = curr_node->parent->level + 1;

                state++;

                switch (state) {
                    case 1:
                        curr_node->parent->left = curr_node;
                        break;
                    case 2:
                        curr_node->parent->right = curr_node;
                        break;
                    default:
                        curr_node->parent->mid = curr_node; // Reached only for the root...
                        break;
                }

                node_map.insert({*ai,curr_node});
                tmp_queue.push_back(curr_node);
            }
        }

        tree_stack.pop();

        if (mode == 0) {
            std::reverse(tmp_queue.begin(), tmp_queue.end());
        } else if (mode == 1) {
            if (!flip) {
                std::reverse(tmp_queue.begin(), tmp_queue.end());
            }
            flip = !flip;
        }

        for (auto &node : tmp_queue) {
            node->prev = cursor;
            if(cursor != nullptr)
                node->prev->next = node;
            cursor = node;
            tree_stack.push(node);
        }
    }

    return root;
}

void drawTrees(GLFWwindow* window,std::vector<GLfloat> coords_1,std::vector<GLfloat> colors_1, std::vector<GLfloat> coords_2,std::vector<GLfloat> colors_2) {

    MyPosData *dataPtr = (MyPosData *) glfwGetWindowUserPointer(window);
    static float alpha = 0;
//attempt to rotate cube
    glRotatef(dataPtr->x, 0, 1, 0);
    glRotatef(dataPtr->y, 1, 0, 0);

/* We have a color array and a vertex array */
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    glVertexPointer(3, GL_FLOAT, 0, coords_1.data());
    glColorPointer(4, GL_FLOAT, 0, colors_1.data());

    glScalef(dataPtr->scale, dataPtr->scale, dataPtr->scale);
    glTranslatef(dataPtr->translationX, dataPtr->translationY, 0);
    glDrawArrays(GL_LINES, 0, coords_1.size()/3);

    glPointSize(10.0);
    glBegin(GL_POINTS);
    glVertex3f(coords_1.at(0),coords_1.at(1),coords_1.at(2));
    glColor4f(1.0f,0.0f,0.0f,1.0f);
    glEnd();

/* Cleanup states */
    glDisableClientState(GL_COLOR_ARRAY);
    glDisableClientState(GL_VERTEX_ARRAY);
    alpha += 1;
}

void MultiTreeManager::compare3DTrees(MultiTreeNode *root_1,MultiTreeNode *root_2, std::map<boost::graph_traits<Mesh>::face_descriptor,Point> centroids) {
    GLFWwindow* window = initWindow(1024, 620);
    MyPosData my_pos_data;
    glfwSetWindowUserPointer(window,&my_pos_data);
    root_1 = root_1->next;
    root_2 = root_2->next;

    std::vector<GLfloat> coords_1, coords_2, colors_1, colors_2;

    while(root_1 != nullptr) {
        Point p = centroids.at(root_1->id);
        Point pp =  centroids.at(root_1->parent->id);
        coords_1.push_back(p.x());
        coords_1.push_back(p.y());
        coords_1.push_back(p.z());
        coords_1.push_back(pp.x());
        coords_1.push_back(pp.y());
        coords_1.push_back(pp.z());

        colors_1.push_back(1.0);
        colors_1.push_back(1.0);
        colors_1.push_back(0.0);
        colors_1.push_back(0.5);
        colors_1.push_back(1.0);
        colors_1.push_back(1.0);
        colors_1.push_back(0.0);
        colors_1.push_back(0.5);

        root_1 = root_1->next;
    }

    while(root_2 != nullptr) {
        Point p = centroids.at(root_2->id);
        Point pp =  centroids.at(root_2->parent->id);
        coords_1.push_back(p.x());
        coords_1.push_back(p.y());
        coords_1.push_back(p.z());
        coords_1.push_back(pp.x());
        coords_1.push_back(pp.y());
        coords_1.push_back(pp.z());

        colors_1.push_back(0.0);
        colors_1.push_back(0.0);
        colors_1.push_back(1.0);
        colors_1.push_back(0.5);
        colors_1.push_back(0.0);
        colors_1.push_back(0.0);
        colors_1.push_back(1.0);
        colors_1.push_back(0.5);

        root_2 = root_2->next;
    }

    my_pos_data.to_display = true;

    while (my_pos_data.to_display) {
        GLint windowWidth, windowHeight;
        glfwGetWindowSize(window, &windowWidth, &windowHeight);
        glViewport(0, 0, windowWidth, windowHeight);

        // Draw stuff
        glClearColor(1.0, 0.0, 0.0, 1.0);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glMatrixMode(GL_PROJECTION_MATRIX);
        glLoadIdentity();

        gluPerspective(60, (double) windowWidth / (double) windowHeight, 0.1, 100);

        glMatrixMode(GL_MODELVIEW_MATRIX);
        glTranslatef(0, 0, -5);

        drawTrees(window,coords_1,colors_1,coords_2,colors_2);

        // Update Screen
        glfwSwapBuffers(window);

        // Check for any input, or window movement
        glfwPollEvents();
    }
}


/*MultiTreeNode* MultiTreeManager::meshToTreeNormal(Mesh mesh, ChainingType mode, int max_depth){
    Dual dual(mesh);
    FiniteDual finiteDual(dual,noborder<Mesh>(mesh));
    boost::graph_traits<FiniteDual>::vertex_descriptor root_dsc = *mesh.faces_begin();

    std::vector<bool> inserted_map(boost::num_vertices(finiteDual),false);
    std::vector<MultiTreeNode*> node_real(boost::num_vertices(finiteDual), nullptr);
    std::vector<std::vector<DualVertexDescriptor>> relatives_id(boost::num_vertices(finiteDual));

    MultiTreeNode* root = new MultiTreeNode;
    root->id = root_dsc;
    root->level = 0;
    inserted_map[root_dsc] = true;
    node_real[0] = root;

    boost::graph_traits<FiniteDual>::adjacency_iterator aib_first,aie_first;
    int state_first = 0;
    for (boost::tie(aib_first,aie_first)=boost::adjacent_vertices(root->id,finiteDual); aib_first != aie_first; ++aib_first) {

        MultiTreeNode *curr_node = new MultiTreeNode;
        curr_node->id = *aib_first;
        curr_node->parent = root;
        curr_node->level = curr_node->parent->level + 1;

        state_first++;

        switch (state_first) {
            case 1:
                curr_node->parent->left = curr_node;
                break;
            case 2:
                curr_node->parent->right = curr_node;
                break;
            default:
                curr_node->parent->mid = curr_node;
                break;
        }

        inserted_map[*aib_first] = true;
        node_real[*aib_first] = curr_node;
    }

    MultiTreeNode* left_node = root->left;
    MultiTreeNode* right_node = root->right;
    MultiTreeNode* mid_node = root->mid;
    omp_lock_t insertion_lock;
    omp_init_lock(&insertion_lock);

#pragma omp parallel num_threads(3) shared(inserted_map,node_real)
    {
        MultiTreeNode *front_element = nullptr;
        MultiTreeNode *cursor = nullptr;

        switch (omp_get_thread_num()) {
            case 0:
                front_element = left_node;
                break;
            case 1:
                front_element = right_node;
                break;
            case 2:
                front_element = mid_node;
                break;
            default:
                std::cerr << "Process number different than expected" << std::endl;
                exit(1);
        }
        cursor = front_element;

        while (front_element != nullptr) {
            std::cout << front_element->id << std::endl;
            boost::graph_traits<FiniteDual>::adjacency_iterator ai,ai_end;

            int state = 0;
            std::vector<MultiTreeNode*> reverse_nodes;

            for (boost::tie(ai,ai_end)=boost::adjacent_vertices(front_element->id,finiteDual);ai != ai_end; ++ai) {
                bool flag = false;
                omp_set_lock(&insertion_lock);
                if(!inserted_map.at(*ai)) {
                    inserted_map.at(*ai) = true;
                    flag = true;
                }
                omp_unset_lock(&insertion_lock);

                if(flag) {
                    if(front_element->id == 4722)
                        int miao = 2;

                    auto *curr_node = new MultiTreeNode;
                    curr_node->id = *ai;
                    curr_node->parent = front_element;
                    curr_node->level = curr_node->parent->level + 1;

                    state++;

                    switch (state) {
                        case 1:
                            curr_node->parent->left = curr_node;
                            break;
                        case 2:
                            curr_node->parent->right = curr_node;
                            break;
                        default:
                            curr_node->parent->mid = curr_node; // Reached only for the root...
                            break;
                    }

                    node_real.at(*ai) = curr_node;
                    reverse_nodes.push_back(curr_node);

                } else {
                    if(front_element->id == 4722)
                        int miao = 2;
                    if(front_element->parent->id != *ai) {
                        relatives_id.at(*ai).emplace_back(front_element->id);
                    }
                }
            }

            std::reverse(reverse_nodes.begin(), reverse_nodes.end());
            for(auto &node : reverse_nodes) {
                node->prev = cursor;
                node->prev->next = node;
                cursor = node;
            }

            front_element = front_element->next;
        }
    }

#pragma omp parallel for num_threads(4)
    for (int i = 0; i < relatives_id.size(); ++i) {
        std::vector<boost::graph_traits<FiniteDual>::vertex_descriptor> elem = relatives_id[i];
        if (!elem.empty()) {
            for (boost::graph_traits<FiniteDual>::vertex_descriptor dsc : elem) {
                node_real[i]->relatives.emplace_back(node_real[dsc]);
            }
        }
    }

    std::queue<MultiTreeNode*> tree_queue;
    tree_queue.push(root);
    MultiTreeNode* cursor = nullptr;
    root->prev = nullptr;
    root->parent = nullptr;

    while(!tree_queue.empty()) {
        MultiTreeNode* curr_node = tree_queue.front();
        curr_node->prev = cursor;
        curr_node->next = nullptr;

        if(cursor != nullptr)
            curr_node->prev->next = curr_node;

        if(curr_node->left != nullptr) {
            tree_queue.push(curr_node->left);
        }

        if(curr_node->right != nullptr) {
            tree_queue.push(curr_node->right);
        }

        if(curr_node->mid != nullptr) {
            tree_queue.push(curr_node->mid);
        }

        cursor = curr_node;
        tree_queue.pop();
    }

    return root;
}*/